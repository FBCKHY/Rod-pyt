# è®¢é˜…ç³»ç»Ÿåç«¯å®ç°æŒ‡å—

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬æŒ‡å—æä¾›äº†è®¢é˜…ç³»ç»Ÿåç«¯æœåŠ¡çš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼ŒåŸºäº Node.js + Express + MySQL æŠ€æœ¯æ ˆã€‚

### ğŸ› ï¸ æŠ€æœ¯æ ˆ

- **è¿è¡Œç¯å¢ƒ**: Node.js 18.20.4+
- **Webæ¡†æ¶**: Express.js 4.18+
- **æ•°æ®åº“**: MySQL 8.0+ / MariaDB 10.6+
- **ORMå·¥å…·**: Sequelize 6.35+
- **èº«ä»½éªŒè¯**: JWT (jsonwebtoken)
- **å‚æ•°éªŒè¯**: express-validator
- **æ–‡æ¡£ç”Ÿæˆ**: Swagger (swagger-jsdoc + swagger-ui-express)
- **è¿›ç¨‹ç®¡ç†**: PM2

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ src/                          # æºç ç›®å½•
â”‚   â”œâ”€â”€ config/                   # é…ç½®æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ database.js           # æ•°æ®åº“é…ç½®
â”‚   â”‚   â”œâ”€â”€ jwt.js                # JWTé…ç½®
â”‚   â”‚   â””â”€â”€ swagger.js            # Swaggeré…ç½®
â”‚   â”œâ”€â”€ controllers/              # æ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ subscriptionController.js
â”‚   â”‚   â””â”€â”€ adminController.js
â”‚   â”œâ”€â”€ middleware/               # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ auth.js               # èº«ä»½éªŒè¯
â”‚   â”‚   â”œâ”€â”€ validation.js         # å‚æ•°éªŒè¯
â”‚   â”‚   â”œâ”€â”€ cors.js               # è·¨åŸŸå¤„ç†
â”‚   â”‚   â””â”€â”€ errorHandler.js       # é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ models/                   # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ index.js              # æ¨¡å‹å…¥å£
â”‚   â”‚   â””â”€â”€ subscription.js       # è®¢é˜…æ¨¡å‹
â”‚   â”œâ”€â”€ routes/                   # è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ subscriptions.js      # è®¢é˜…è·¯ç”±
â”‚   â”‚   â””â”€â”€ admin.js              # ç®¡ç†å‘˜è·¯ç”±
â”‚   â”œâ”€â”€ services/                 # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ subscriptionService.js
â”‚   â”‚   â””â”€â”€ statsService.js
â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ logger.js             # æ—¥å¿—å·¥å…·
â”‚   â”‚   â”œâ”€â”€ response.js           # å“åº”æ ¼å¼åŒ–
â”‚   â”‚   â””â”€â”€ validator.js          # éªŒè¯å·¥å…·
â”‚   â””â”€â”€ app.js                    # åº”ç”¨å…¥å£
â”œâ”€â”€ migrations/                   # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ seeders/                      # æ•°æ®å¡«å……
â”œâ”€â”€ tests/                        # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ logs/                         # æ—¥å¿—æ–‡ä»¶
â”œâ”€â”€ docs/                         # æ–‡æ¡£
â”œâ”€â”€ scripts/                      # è„šæœ¬æ–‡ä»¶
â”‚   â”œâ”€â”€ setup.js                  # åˆå§‹åŒ–è„šæœ¬
â”‚   â””â”€â”€ deploy.js                 # éƒ¨ç½²è„šæœ¬
â”œâ”€â”€ .env.example                  # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”œâ”€â”€ .gitignore                    # Gitå¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ package.json                  # é¡¹ç›®é…ç½®
â”œâ”€â”€ ecosystem.config.js           # PM2é…ç½®
â””â”€â”€ README.md                     # é¡¹ç›®è¯´æ˜
```

---

## ğŸ”§ ç¯å¢ƒé…ç½®

### 1. ç¯å¢ƒå˜é‡ (.env)

```bash
# æœåŠ¡å™¨é…ç½®
NODE_ENV=development
PORT=3000
HOST=localhost

# æ•°æ®åº“é…ç½®
DB_HOST=localhost
DB_PORT=3306
DB_NAME=subscription_system
DB_USERNAME=root
DB_PASSWORD=your_password
DB_DIALECT=mysql

# JWTé…ç½®
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=7d

# æ—¥å¿—é…ç½®
LOG_LEVEL=info
LOG_FILE=./logs/app.log

# CORSé…ç½®
CORS_ORIGIN=http://localhost:3006,http://localhost:8080

# å…¶ä»–é…ç½®
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX=100
```

### 2. package.json

```json
{
  "name": "subscription-system-backend",
  "version": "1.0.0",
  "description": "è®¢é˜…ç³»ç»Ÿåç«¯æœåŠ¡",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:setup": "npm run db:migrate && npm run db:seed",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "setup": "node scripts/setup.js",
    "deploy": "node scripts/deploy.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "sequelize": "^6.35.2",
    "mysql2": "^3.6.5",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "express-validator": "^7.0.1",
    "express-rate-limit": "^7.1.5",
    "helmet": "^7.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "winston": "^3.11.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "express-async-errors": "^3.1.1",
    "joi": "^17.11.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.56.0",
    "sequelize-cli": "^6.6.2"
  },
  "engines": {
    "node": ">=18.20.4"
  }
}
```

---

## ğŸ—„ï¸ æ•°æ®åº“å®ç°

### 1. æ•°æ®åº“é…ç½® (src/config/database.js)

```javascript
const { Sequelize } = require('sequelize');
require('dotenv').config();

const sequelize = new Sequelize({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  database: process.env.DB_NAME || 'subscription_system',
  username: process.env.DB_USERNAME || 'root',
  password: process.env.DB_PASSWORD || '',
  dialect: process.env.DB_DIALECT || 'mysql',
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  pool: {
    max: 10,
    min: 0,
    acquire: 30000,
    idle: 10000
  },
  define: {
    timestamps: true,
    underscored: true,
    freezeTableName: true
  }
});

module.exports = sequelize;
```

### 2. è®¢é˜…æ¨¡å‹ (src/models/subscription.js)

```javascript
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Subscription = sequelize.define('Subscription', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    comment: 'è®¢é˜…ID'
  },
  contactType: {
    type: DataTypes.ENUM('email', 'wechat', 'phone'),
    allowNull: false,
    field: 'contact_type',
    comment: 'è”ç³»æ–¹å¼ç±»å‹'
  },
  contactValue: {
    type: DataTypes.STRING(255),
    allowNull: false,
    field: 'contact_value',
    comment: 'è”ç³»æ–¹å¼å€¼'
  },
  source: {
    type: DataTypes.ENUM('website_footer', 'contact_form', 'manual'),
    allowNull: false,
    comment: 'è®¢é˜…æ¥æº'
  },
  status: {
    type: DataTypes.ENUM('subscribed', 'unsubscribed'),
    defaultValue: 'subscribed',
    comment: 'è®¢é˜…çŠ¶æ€'
  },
  subscribedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
    field: 'subscribed_at',
    comment: 'è®¢é˜…æ—¶é—´'
  },
  ipAddress: {
    type: DataTypes.STRING(45),
    allowNull: true,
    field: 'ip_address',
    comment: 'IPåœ°å€'
  },
  userAgent: {
    type: DataTypes.TEXT,
    allowNull: true,
    field: 'user_agent',
    comment: 'ç”¨æˆ·ä»£ç†ä¿¡æ¯'
  }
}, {
  tableName: 'subscriptions',
  indexes: [
    {
      unique: true,
      fields: ['contact_type', 'contact_value'],
      name: 'unique_contact'
    },
    {
      fields: ['status']
    },
    {
      fields: ['source']
    },
    {
      fields: ['created_at']
    },
    {
      fields: ['contact_type']
    }
  ]
});

module.exports = Subscription;
```

### 3. æ•°æ®åº“è¿ç§» (migrations/001-create-subscriptions.js)

```javascript
'use strict';

module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('subscriptions', {
      id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true,
        comment: 'è®¢é˜…ID'
      },
      contact_type: {
        type: Sequelize.ENUM('email', 'wechat', 'phone'),
        allowNull: false,
        comment: 'è”ç³»æ–¹å¼ç±»å‹'
      },
      contact_value: {
        type: Sequelize.STRING(255),
        allowNull: false,
        comment: 'è”ç³»æ–¹å¼å€¼'
      },
      source: {
        type: Sequelize.ENUM('website_footer', 'contact_form', 'manual'),
        allowNull: false,
        comment: 'è®¢é˜…æ¥æº'
      },
      status: {
        type: Sequelize.ENUM('subscribed', 'unsubscribed'),
        defaultValue: 'subscribed',
        comment: 'è®¢é˜…çŠ¶æ€'
      },
      subscribed_at: {
        type: Sequelize.DATE,
        defaultValue: Sequelize.NOW,
        comment: 'è®¢é˜…æ—¶é—´'
      },
      ip_address: {
        type: Sequelize.STRING(45),
        allowNull: true,
        comment: 'IPåœ°å€'
      },
      user_agent: {
        type: Sequelize.TEXT,
        allowNull: true,
        comment: 'ç”¨æˆ·ä»£ç†ä¿¡æ¯'
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.NOW
      }
    });

    // æ·»åŠ å”¯ä¸€ç´¢å¼•
    await queryInterface.addIndex('subscriptions', 
      ['contact_type', 'contact_value'], 
      {
        unique: true,
        name: 'unique_contact'
      }
    );

    // æ·»åŠ å…¶ä»–ç´¢å¼•
    await queryInterface.addIndex('subscriptions', ['status']);
    await queryInterface.addIndex('subscriptions', ['source']);
    await queryInterface.addIndex('subscriptions', ['created_at']);
    await queryInterface.addIndex('subscriptions', ['contact_type']);
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('subscriptions');
  }
};
```

---

## ğŸš€ åº”ç”¨å…¥å£ (src/app.js)

```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('express-async-errors');
require('dotenv').config();

const sequelize = require('./config/database');
const logger = require('./utils/logger');
const errorHandler = require('./middleware/errorHandler');
const { formatResponse } = require('./utils/response');

// è·¯ç”±
const subscriptionRoutes = require('./routes/subscriptions');
const adminRoutes = require('./routes/admin');

const app = express();

// åŸºç¡€ä¸­é—´ä»¶
app.use(helmet());
app.use(cors({
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3006'],
  credentials: true
}));

// é€Ÿç‡é™åˆ¶
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_MAX) || 100,
  message: formatResponse(429, 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•')
});
app.use('/api/', limiter);

// JSONè§£æ
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// è¯·æ±‚æ—¥å¿—
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.path}`, {
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    body: req.method === 'POST' ? req.body : undefined
  });
  next();
});

// å¥åº·æ£€æŸ¥
app.get('/health', (req, res) => {
  res.json(formatResponse(200, 'Service is healthy', {
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV
  }));
});

// APIè·¯ç”±
app.use('/api/subscriptions', subscriptionRoutes);
app.use('/api/admin', adminRoutes);

// Swaggeræ–‡æ¡£
if (process.env.NODE_ENV === 'development') {
  const swaggerUi = require('swagger-ui-express');
  const swaggerSpec = require('./config/swagger');
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
}

// 404å¤„ç†
app.use('*', (req, res) => {
  res.status(404).json(formatResponse(404, 'æ¥å£ä¸å­˜åœ¨'));
});

// é”™è¯¯å¤„ç†
app.use(errorHandler);

// æ•°æ®åº“è¿æ¥å’ŒæœåŠ¡å™¨å¯åŠ¨
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || 'localhost';

async function startServer() {
  try {
    // æµ‹è¯•æ•°æ®åº“è¿æ¥
    await sequelize.authenticate();
    logger.info('æ•°æ®åº“è¿æ¥æˆåŠŸ');

    // åŒæ­¥æ•°æ®åº“æ¨¡å‹ï¼ˆç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨è¿ç§»ï¼‰
    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
      logger.info('æ•°æ®åº“æ¨¡å‹åŒæ­¥å®Œæˆ');
    }

    // å¯åŠ¨æœåŠ¡å™¨
    app.listen(PORT, HOST, () => {
      logger.info(`æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ`, {
        port: PORT,
        host: HOST,
        env: process.env.NODE_ENV,
        docs: process.env.NODE_ENV === 'development' ? `http://${HOST}:${PORT}/api-docs` : null
      });
    });

  } catch (error) {
    logger.error('æœåŠ¡å™¨å¯åŠ¨å¤±è´¥', error);
    process.exit(1);
  }
}

// ä¼˜é›…å…³é—­
process.on('SIGTERM', async () => {
  logger.info('æ¥æ”¶åˆ°SIGTERMä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...');
  await sequelize.close();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('æ¥æ”¶åˆ°SIGINTä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...');
  await sequelize.close();
  process.exit(0);
});

startServer();

module.exports = app;
```

---

## ğŸ¯ æ§åˆ¶å™¨å®ç°

### 1. è®¢é˜…æ§åˆ¶å™¨ (src/controllers/subscriptionController.js)

```javascript
const subscriptionService = require('../services/subscriptionService');
const { formatResponse } = require('../utils/response');
const logger = require('../utils/logger');

class SubscriptionController {
  /**
   * åˆ›å»ºè®¢é˜…
   */
  async create(req, res) {
    const { contactType, contactValue, source } = req.body;
    const ipAddress = req.ip || req.connection.remoteAddress;
    const userAgent = req.get('User-Agent');

    try {
      const subscription = await subscriptionService.createSubscription({
        contactType,
        contactValue,
        source,
        ipAddress,
        userAgent
      });

      logger.info('è®¢é˜…åˆ›å»ºæˆåŠŸ', { 
        subscriptionId: subscription.id,
        contactType,
        contactValue,
        source 
      });

      res.status(201).json(formatResponse(200, 'è®¢é˜…æˆåŠŸ', subscription));
    } catch (error) {
      if (error.name === 'ValidationError') {
        return res.status(400).json(formatResponse(400, error.message));
      }
      if (error.name === 'UniqueConstraintError') {
        return res.status(409).json(formatResponse(409, 'è¯¥è”ç³»æ–¹å¼å·²å­˜åœ¨'));
      }
      
      logger.error('åˆ›å»ºè®¢é˜…å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }
}

module.exports = new SubscriptionController();
```

### 2. ç®¡ç†å‘˜æ§åˆ¶å™¨ (src/controllers/adminController.js)

```javascript
const subscriptionService = require('../services/subscriptionService');
const statsService = require('../services/statsService');
const { formatResponse } = require('../utils/response');
const logger = require('../utils/logger');

class AdminController {
  /**
   * è·å–è®¢é˜…åˆ—è¡¨
   */
  async getSubscriptions(req, res) {
    try {
      const {
        page = 1,
        size = 20,
        status,
        contactType,
        source,
        contact,
        startDate,
        endDate
      } = req.query;

      const result = await subscriptionService.getSubscriptionList({
        page: parseInt(page),
        size: parseInt(size),
        status,
        contactType,
        source,
        contact,
        startDate,
        endDate
      });

      res.json(formatResponse(200, 'æŸ¥è¯¢æˆåŠŸ', result));
    } catch (error) {
      logger.error('è·å–è®¢é˜…åˆ—è¡¨å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * åˆ‡æ¢è®¢é˜…çŠ¶æ€
   */
  async toggleStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;

      const subscription = await subscriptionService.updateSubscriptionStatus(
        parseInt(id),
        status
      );

      if (!subscription) {
        return res.status(404).json(formatResponse(404, 'è®¢é˜…è®°å½•ä¸å­˜åœ¨'));
      }

      logger.info('è®¢é˜…çŠ¶æ€æ›´æ–°æˆåŠŸ', { 
        subscriptionId: id,
        newStatus: status 
      });

      res.json(formatResponse(200, 'çŠ¶æ€æ›´æ–°æˆåŠŸ', subscription));
    } catch (error) {
      logger.error('æ›´æ–°è®¢é˜…çŠ¶æ€å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * åˆ é™¤è®¢é˜…
   */
  async deleteSubscription(req, res) {
    try {
      const { id } = req.params;
      
      const deleted = await subscriptionService.deleteSubscription(parseInt(id));
      
      if (!deleted) {
        return res.status(404).json(formatResponse(404, 'è®¢é˜…è®°å½•ä¸å­˜åœ¨'));
      }

      logger.info('è®¢é˜…åˆ é™¤æˆåŠŸ', { subscriptionId: id });

      res.json(formatResponse(200, 'åˆ é™¤æˆåŠŸ', { deletedId: parseInt(id) }));
    } catch (error) {
      logger.error('åˆ é™¤è®¢é˜…å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * æ‰¹é‡åˆ é™¤è®¢é˜…
   */
  async batchDelete(req, res) {
    try {
      const { ids } = req.body;
      
      if (!Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json(formatResponse(400, 'è¯·æä¾›æœ‰æ•ˆçš„IDåˆ—è¡¨'));
      }

      const deletedCount = await subscriptionService.batchDeleteSubscriptions(ids);

      logger.info('æ‰¹é‡åˆ é™¤å®Œæˆ', { 
        requestedIds: ids,
        deletedCount 
      });

      res.json(formatResponse(200, 'æ‰¹é‡åˆ é™¤æˆåŠŸ', {
        deletedCount,
        deletedIds: ids
      }));
    } catch (error) {
      logger.error('æ‰¹é‡åˆ é™¤å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * åˆ›å»ºè®¢é˜…
   */
  async createSubscription(req, res) {
    try {
      const { contactType, contactValue, source = 'manual' } = req.body;

      const subscription = await subscriptionService.createSubscription({
        contactType,
        contactValue,
        source,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      });

      logger.info('ç®¡ç†å‘˜åˆ›å»ºè®¢é˜…æˆåŠŸ', { 
        subscriptionId: subscription.id,
        contactType,
        contactValue 
      });

      res.status(201).json(formatResponse(200, 'æ·»åŠ æˆåŠŸ', subscription));
    } catch (error) {
      if (error.name === 'ValidationError') {
        return res.status(400).json(formatResponse(400, error.message));
      }
      if (error.name === 'UniqueConstraintError') {
        return res.status(409).json(formatResponse(409, 'è¯¥è”ç³»æ–¹å¼å·²å­˜åœ¨'));
      }
      
      logger.error('ç®¡ç†å‘˜åˆ›å»ºè®¢é˜…å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®
   */
  async getStats(req, res) {
    try {
      const stats = await statsService.getSubscriptionStats();
      res.json(formatResponse(200, 'æŸ¥è¯¢æˆåŠŸ', stats));
    } catch (error) {
      logger.error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }

  /**
   * æ£€æŸ¥è”ç³»æ–¹å¼æ˜¯å¦å­˜åœ¨
   */
  async checkExists(req, res) {
    try {
      const { contactType, contactValue } = req.query;

      if (!contactType || !contactValue) {
        return res.status(400).json(formatResponse(400, 'ç¼ºå°‘å¿…è¦å‚æ•°'));
      }

      const subscription = await subscriptionService.findByContact(
        contactType,
        contactValue
      );

      res.json(formatResponse(200, 'æŸ¥è¯¢æˆåŠŸ', {
        exists: !!subscription,
        subscription: subscription || null
      }));
    } catch (error) {
      logger.error('æ£€æŸ¥è”ç³»æ–¹å¼å¤±è´¥', error);
      res.status(500).json(formatResponse(500, 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
    }
  }
}

module.exports = new AdminController();
```

---

## ğŸ” ä¸­é—´ä»¶å®ç°

### 1. JWTè®¤è¯ä¸­é—´ä»¶ (src/middleware/auth.js)

```javascript
const jwt = require('jsonwebtoken');
const { formatResponse } = require('../utils/response');

const auth = (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json(formatResponse(401, 'è®¿é—®ä»¤ç‰Œç¼ºå¤±'));
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json(formatResponse(401, 'è®¿é—®ä»¤ç‰Œå·²è¿‡æœŸ'));
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json(formatResponse(401, 'æ— æ•ˆçš„è®¿é—®ä»¤ç‰Œ'));
    }
    
    return res.status(401).json(formatResponse(401, 'èº«ä»½éªŒè¯å¤±è´¥'));
  }
};

module.exports = auth;
```

### 2. å‚æ•°éªŒè¯ä¸­é—´ä»¶ (src/middleware/validation.js)

```javascript
const { body, query, validationResult } = require('express-validator');
const { formatResponse } = require('../utils/response');

// åˆ›å»ºè®¢é˜…éªŒè¯è§„åˆ™
const createSubscriptionValidation = [
  body('contactType')
    .isIn(['email', 'wechat', 'phone'])
    .withMessage('è”ç³»æ–¹å¼ç±»å‹æ— æ•ˆ'),
  
  body('contactValue')
    .trim()
    .notEmpty()
    .withMessage('è”ç³»æ–¹å¼ä¸èƒ½ä¸ºç©º')
    .isLength({ max: 255 })
    .withMessage('è”ç³»æ–¹å¼é•¿åº¦ä¸èƒ½è¶…è¿‡255ä¸ªå­—ç¬¦')
    .custom((value, { req }) => {
      const { contactType } = req.body;
      
      switch (contactType) {
        case 'email':
          if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
            throw new Error('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®');
          }
          break;
        case 'phone':
          if (!/^1[3-9]\d{9}$/.test(value)) {
            throw new Error('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®');
          }
          break;
        case 'wechat':
          if (!/^[a-zA-Z][a-zA-Z0-9_-]{5,19}$/.test(value)) {
            throw new Error('å¾®ä¿¡å·æ ¼å¼ä¸æ­£ç¡®');
          }
          break;
      }
      return true;
    }),
  
  body('source')
    .isIn(['website_footer', 'contact_form', 'manual'])
    .withMessage('è®¢é˜…æ¥æºæ— æ•ˆ')
];

// æŸ¥è¯¢éªŒè¯è§„åˆ™
const queryValidation = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('é¡µç å¿…é¡»æ˜¯å¤§äº0çš„æ•´æ•°'),
  
  query('size')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('æ¯é¡µæ¡æ•°å¿…é¡»æ˜¯1-100ä¹‹é—´çš„æ•´æ•°'),
  
  query('status')
    .optional()
    .isIn(['subscribed', 'unsubscribed'])
    .withMessage('çŠ¶æ€å€¼æ— æ•ˆ'),
  
  query('contactType')
    .optional()
    .isIn(['email', 'wechat', 'phone'])
    .withMessage('è”ç³»æ–¹å¼ç±»å‹æ— æ•ˆ'),
  
  query('source')
    .optional()
    .isIn(['website_footer', 'contact_form', 'manual'])
    .withMessage('è®¢é˜…æ¥æºæ— æ•ˆ')
];

// çŠ¶æ€æ›´æ–°éªŒè¯è§„åˆ™
const statusUpdateValidation = [
  body('status')
    .isIn(['subscribed', 'unsubscribed'])
    .withMessage('çŠ¶æ€å€¼æ— æ•ˆ')
];

// éªŒè¯ç»“æœå¤„ç†
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const firstError = errors.array()[0];
    return res.status(400).json(formatResponse(400, firstError.msg));
  }
  
  next();
};

module.exports = {
  createSubscriptionValidation,
  queryValidation,
  statusUpdateValidation,
  handleValidationErrors
};
```

### 3. é”™è¯¯å¤„ç†ä¸­é—´ä»¶ (src/middleware/errorHandler.js)

```javascript
const logger = require('../utils/logger');
const { formatResponse } = require('../utils/response');

const errorHandler = (err, req, res, next) => {
  logger.error('æœªæ•è·çš„é”™è¯¯', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  // Sequelize éªŒè¯é”™è¯¯
  if (err.name === 'SequelizeValidationError') {
    const message = err.errors.map(e => e.message).join(', ');
    return res.status(400).json(formatResponse(400, message));
  }

  // Sequelize å”¯ä¸€çº¦æŸé”™è¯¯
  if (err.name === 'SequelizeUniqueConstraintError') {
    return res.status(409).json(formatResponse(409, 'æ•°æ®å·²å­˜åœ¨'));
  }

  // JWT é”™è¯¯
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json(formatResponse(401, 'æ— æ•ˆçš„è®¿é—®ä»¤ç‰Œ'));
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json(formatResponse(401, 'è®¿é—®ä»¤ç‰Œå·²è¿‡æœŸ'));
  }

  // è¯­æ³•é”™è¯¯
  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
    return res.status(400).json(formatResponse(400, 'è¯·æ±‚æ•°æ®æ ¼å¼é”™è¯¯'));
  }

  // é»˜è®¤æœåŠ¡å™¨é”™è¯¯
  const statusCode = err.statusCode || 500;
  const message = process.env.NODE_ENV === 'production' 
    ? 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯' 
    : err.message;

  res.status(statusCode).json(formatResponse(statusCode, message));
};

module.exports = errorHandler;
```

---

## ğŸ¢ ä¸šåŠ¡é€»è¾‘å®ç°

### 1. è®¢é˜…æœåŠ¡ (src/services/subscriptionService.js)

```javascript
const { Op } = require('sequelize');
const Subscription = require('../models/subscription');

class SubscriptionService {
  /**
   * åˆ›å»ºè®¢é˜…
   */
  async createSubscription(data) {
    return await Subscription.create(data);
  }

  /**
   * æ ¹æ®è”ç³»æ–¹å¼æŸ¥æ‰¾è®¢é˜…
   */
  async findByContact(contactType, contactValue) {
    return await Subscription.findOne({
      where: {
        contactType,
        contactValue
      }
    });
  }

  /**
   * è·å–è®¢é˜…åˆ—è¡¨
   */
  async getSubscriptionList(params) {
    const {
      page = 1,
      size = 20,
      status,
      contactType,
      source,
      contact,
      startDate,
      endDate
    } = params;

    const where = {};

    // æ¡ä»¶ç­›é€‰
    if (status) where.status = status;
    if (contactType) where.contactType = contactType;
    if (source) where.source = source;
    if (contact) {
      where.contactValue = {
        [Op.like]: `%${contact}%`
      };
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt[Op.gte] = new Date(startDate);
      if (endDate) where.createdAt[Op.lte] = new Date(endDate + ' 23:59:59');
    }

    const offset = (page - 1) * size;

    const { count, rows } = await Subscription.findAndCountAll({
      where,
      limit: size,
      offset,
      order: [['createdAt', 'DESC']],
      attributes: [
        'id', 'contactType', 'contactValue', 'source', 'status',
        'subscribedAt', 'ipAddress', 'userAgent', 'createdAt', 'updatedAt'
      ]
    });

    return {
      list: rows,
      pagination: {
        page,
        size,
        total: count,
        pages: Math.ceil(count / size)
      }
    };
  }

  /**
   * æ›´æ–°è®¢é˜…çŠ¶æ€
   */
  async updateSubscriptionStatus(id, status) {
    const [updatedRowsCount] = await Subscription.update(
      { status },
      {
        where: { id },
        returning: true
      }
    );

    if (updatedRowsCount === 0) {
      return null;
    }

    return await Subscription.findByPk(id);
  }

  /**
   * åˆ é™¤è®¢é˜…
   */
  async deleteSubscription(id) {
    const deletedRowsCount = await Subscription.destroy({
      where: { id }
    });

    return deletedRowsCount > 0;
  }

  /**
   * æ‰¹é‡åˆ é™¤è®¢é˜…
   */
  async batchDeleteSubscriptions(ids) {
    return await Subscription.destroy({
      where: {
        id: {
          [Op.in]: ids
        }
      }
    });
  }
}

module.exports = new SubscriptionService();
```

### 2. ç»Ÿè®¡æœåŠ¡ (src/services/statsService.js)

```javascript
const { Op, fn, col, literal } = require('sequelize');
const Subscription = require('../models/subscription');

class StatsService {
  /**
   * è·å–è®¢é˜…ç»Ÿè®¡æ•°æ®
   */
  async getSubscriptionStats() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const thisWeekStart = new Date(today.getTime() - (today.getDay() * 24 * 60 * 60 * 1000));
    const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);

    // åŸºç¡€ç»Ÿè®¡
    const [
      total,
      subscribed,
      unsubscribed,
      todayNew,
      thisWeekNew,
      thisMonthNew
    ] = await Promise.all([
      this.getTotalCount(),
      this.getCountByStatus('subscribed'),
      this.getCountByStatus('unsubscribed'),
      this.getCountByDateRange(today, new Date(today.getTime() + 24 * 60 * 60 * 1000)),
      this.getCountByDateRange(thisWeekStart, now),
      this.getCountByDateRange(thisMonthStart, now)
    ]);

    // æŒ‰è”ç³»æ–¹å¼ç±»å‹ç»Ÿè®¡
    const byContactType = await this.getCountByContactType();

    // æŒ‰æ¥æºç»Ÿè®¡
    const bySource = await this.getCountBySource();

    // è¶‹åŠ¿æ•°æ®ï¼ˆæœ€è¿‘7å¤©ï¼‰
    const trend = await this.getTrendData(7);

    return {
      total,
      subscribed,
      unsubscribed,
      todayNew,
      thisWeekNew,
      thisMonthNew,
      byContactType,
      bySource,
      trend
    };
  }

  /**
   * è·å–æ€»æ•°
   */
  async getTotalCount() {
    return await Subscription.count();
  }

  /**
   * æŒ‰çŠ¶æ€ç»Ÿè®¡
   */
  async getCountByStatus(status) {
    return await Subscription.count({
      where: { status }
    });
  }

  /**
   * æŒ‰æ—¥æœŸèŒƒå›´ç»Ÿè®¡
   */
  async getCountByDateRange(startDate, endDate) {
    return await Subscription.count({
      where: {
        createdAt: {
          [Op.gte]: startDate,
          [Op.lt]: endDate
        }
      }
    });
  }

  /**
   * æŒ‰è”ç³»æ–¹å¼ç±»å‹ç»Ÿè®¡
   */
  async getCountByContactType() {
    const results = await Subscription.findAll({
      attributes: [
        'contactType',
        [fn('COUNT', col('id')), 'count']
      ],
      group: ['contactType'],
      raw: true
    });

    const stats = { email: 0, wechat: 0, phone: 0 };
    results.forEach(item => {
      stats[item.contactType] = parseInt(item.count);
    });

    return stats;
  }

  /**
   * æŒ‰æ¥æºç»Ÿè®¡
   */
  async getCountBySource() {
    const results = await Subscription.findAll({
      attributes: [
        'source',
        [fn('COUNT', col('id')), 'count']
      ],
      group: ['source'],
      raw: true
    });

    const stats = { website_footer: 0, contact_form: 0, manual: 0 };
    results.forEach(item => {
      stats[item.source] = parseInt(item.count);
    });

    return stats;
  }

  /**
   * è·å–è¶‹åŠ¿æ•°æ®
   */
  async getTrendData(days) {
    const endDate = new Date();
    const startDate = new Date(endDate.getTime() - (days * 24 * 60 * 60 * 1000));

    const subscriptionTrend = await Subscription.findAll({
      attributes: [
        [fn('DATE', col('created_at')), 'date'],
        [fn('COUNT', col('id')), 'newSubscriptions']
      ],
      where: {
        createdAt: {
          [Op.gte]: startDate,
          [Op.lte]: endDate
        }
      },
      group: [fn('DATE', col('created_at'))],
      order: [[fn('DATE', col('created_at')), 'ASC']],
      raw: true
    });

    const unsubscriptionTrend = await Subscription.findAll({
      attributes: [
        [fn('DATE', col('updated_at')), 'date'],
        [fn('COUNT', col('id')), 'unsubscriptions']
      ],
      where: {
        status: 'unsubscribed',
        updatedAt: {
          [Op.gte]: startDate,
          [Op.lte]: endDate
        }
      },
      group: [fn('DATE', col('updated_at'))],
      order: [[fn('DATE', col('updated_at')), 'ASC']],
      raw: true
    });

    // åˆå¹¶æ•°æ®
    const trendMap = new Map();
    
    subscriptionTrend.forEach(item => {
      trendMap.set(item.date, {
        date: item.date,
        newSubscriptions: parseInt(item.newSubscriptions),
        unsubscriptions: 0
      });
    });

    unsubscriptionTrend.forEach(item => {
      const existing = trendMap.get(item.date);
      if (existing) {
        existing.unsubscriptions = parseInt(item.unsubscriptions);
      } else {
        trendMap.set(item.date, {
          date: item.date,
          newSubscriptions: 0,
          unsubscriptions: parseInt(item.unsubscriptions)
        });
      }
    });

    return Array.from(trendMap.values()).sort((a, b) => 
      new Date(a.date) - new Date(b.date)
    );
  }
}

module.exports = new StatsService();
```

---

## ğŸ›£ï¸ è·¯ç”±é…ç½®

### 1. è®¢é˜…è·¯ç”± (src/routes/subscriptions.js)

```javascript
const express = require('express');
const subscriptionController = require('../controllers/subscriptionController');
const {
  createSubscriptionValidation,
  handleValidationErrors
} = require('../middleware/validation');

const router = express.Router();

/**
 * @swagger
 * /api/subscriptions:
 *   post:
 *     summary: åˆ›å»ºè®¢é˜…
 *     tags: [Subscriptions]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - contactType
 *               - contactValue
 *               - source
 *             properties:
 *               contactType:
 *                 type: string
 *                 enum: [email, wechat, phone]
 *               contactValue:
 *                 type: string
 *               source:
 *                 type: string
 *                 enum: [website_footer, contact_form, manual]
 *     responses:
 *       200:
 *         description: è®¢é˜…æˆåŠŸ
 *       400:
 *         description: è¯·æ±‚å‚æ•°é”™è¯¯
 *       409:
 *         description: è”ç³»æ–¹å¼å·²å­˜åœ¨
 */
router.post('/',
  createSubscriptionValidation,
  handleValidationErrors,
  subscriptionController.create
);

module.exports = router;
```

### 2. ç®¡ç†å‘˜è·¯ç”± (src/routes/admin.js)

```javascript
const express = require('express');
const adminController = require('../controllers/adminController');
const auth = require('../middleware/auth');
const {
  queryValidation,
  createSubscriptionValidation,
  statusUpdateValidation,
  handleValidationErrors
} = require('../middleware/validation');

const router = express.Router();

// æ‰€æœ‰ç®¡ç†å‘˜è·¯ç”±éƒ½éœ€è¦è®¤è¯
router.use(auth);

/**
 * @swagger
 * /api/admin/subscriptions:
 *   get:
 *     summary: è·å–è®¢é˜…åˆ—è¡¨
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 */
router.get('/subscriptions',
  queryValidation,
  handleValidationErrors,
  adminController.getSubscriptions
);

router.post('/subscriptions',
  createSubscriptionValidation,
  handleValidationErrors,
  adminController.createSubscription
);

router.put('/subscriptions/:id/status',
  statusUpdateValidation,
  handleValidationErrors,
  adminController.toggleStatus
);

router.delete('/subscriptions/:id',
  adminController.deleteSubscription
);

router.delete('/subscriptions/batch',
  adminController.batchDelete
);

router.get('/subscriptions/stats',
  adminController.getStats
);

router.get('/subscriptions/check',
  adminController.checkExists
);

module.exports = router;
```

---

## ğŸš€ éƒ¨ç½²é…ç½®

### 1. PM2é…ç½® (ecosystem.config.js)

```javascript
module.exports = {
  apps: [{
    name: 'subscription-system-backend',
    script: 'src/app.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    error_file: './logs/pm2-error.log',
    out_file: './logs/pm2-out.log',
    log_file: './logs/pm2-combined.log',
    time: true,
    max_memory_restart: '1G',
    node_args: '--max_old_space_size=1024'
  }]
};
```

### 2. Dockeré…ç½® (Dockerfile)

```dockerfile
FROM node:18.20.4-alpine

WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production

# å¤åˆ¶æºç 
COPY src/ ./src/

# åˆ›å»ºæ—¥å¿—ç›®å½•
RUN mkdir -p logs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨å‘½ä»¤
CMD ["node", "src/app.js"]
```

### 3. Docker Composeé…ç½® (docker-compose.yml)

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - DB_NAME=subscription_system
      - DB_USERNAME=root
      - DB_PASSWORD=your_password
    depends_on:
      - mysql
    volumes:
      - ./logs:/app/logs

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: your_password
      MYSQL_DATABASE: subscription_system
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```

---

## ğŸ“‹ éƒ¨ç½²æ­¥éª¤

### 1. ç¯å¢ƒå‡†å¤‡

```bash
# å®‰è£…Node.js 18.20.4+
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# å®‰è£…PM2
npm install -g pm2

# å®‰è£…MySQL
sudo apt update
sudo apt install mysql-server
```

### 2. é¡¹ç›®éƒ¨ç½²

```bash
# å…‹éš†é¡¹ç›®
git clone <your-repo-url>
cd subscription-system-backend

# å®‰è£…ä¾èµ–
npm install

# é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env
nano .env

# è¿è¡Œæ•°æ®åº“è¿ç§»
npm run db:migrate

# å¯åŠ¨æœåŠ¡
pm2 start ecosystem.config.js --env production

# ä¿å­˜PM2é…ç½®
pm2 save
pm2 startup
```

### 3. Nginxé…ç½®

```nginx
server {
    listen 80;
    server_name api.yourdomain.com;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### 1. å•å…ƒæµ‹è¯• (tests/services/subscriptionService.test.js)

```javascript
const subscriptionService = require('../../src/services/subscriptionService');
const Subscription = require('../../src/models/subscription');

describe('SubscriptionService', () => {
  beforeEach(async () => {
    await Subscription.destroy({ where: {}, truncate: true });
  });

  describe('createSubscription', () => {
    it('should create a subscription successfully', async () => {
      const subscriptionData = {
        contactType: 'email',
        contactValue: 'test@example.com',
        source: 'website_footer'
      };

      const subscription = await subscriptionService.createSubscription(subscriptionData);

      expect(subscription).toBeDefined();
      expect(subscription.contactType).toBe('email');
      expect(subscription.contactValue).toBe('test@example.com');
      expect(subscription.status).toBe('subscribed');
    });

    it('should reject duplicate contacts', async () => {
      const subscriptionData = {
        contactType: 'email',
        contactValue: 'test@example.com',
        source: 'website_footer'
      };

      await subscriptionService.createSubscription(subscriptionData);

      await expect(
        subscriptionService.createSubscription(subscriptionData)
      ).rejects.toThrow();
    });
  });
});
```

### 2. é›†æˆæµ‹è¯• (tests/routes/subscriptions.test.js)

```javascript
const request = require('supertest');
const app = require('../../src/app');

describe('/api/subscriptions', () => {
  describe('POST /', () => {
    it('should create subscription with valid data', async () => {
      const subscriptionData = {
        contactType: 'email',
        contactValue: 'test@example.com',
        source: 'website_footer'
      };

      const response = await request(app)
        .post('/api/subscriptions')
        .send(subscriptionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.msg).toBe('è®¢é˜…æˆåŠŸ');
      expect(response.body.data.contactValue).toBe('test@example.com');
    });

    it('should reject invalid email format', async () => {
      const subscriptionData = {
        contactType: 'email',
        contactValue: 'invalid-email',
        source: 'website_footer'
      };

      const response = await request(app)
        .post('/api/subscriptions')
        .send(subscriptionData)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.msg).toContain('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®');
    });
  });
});
```

---

## ğŸ¯ å¯åŠ¨å’ŒéªŒè¯

### 1. å¼€å‘ç¯å¢ƒå¯åŠ¨

```bash
# å®‰è£…ä¾èµ–
npm install

# é…ç½®ç¯å¢ƒå˜é‡
cp .env.example .env

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev
```

### 2. æ¥å£æµ‹è¯•

```bash
# æµ‹è¯•è®¢é˜…æ¥å£
curl -X POST http://localhost:3000/api/subscriptions \
  -H "Content-Type: application/json" \
  -d '{
    "contactType": "email",
    "contactValue": "test@example.com",
    "source": "website_footer"
  }'

# æµ‹è¯•å¥åº·æ£€æŸ¥
curl http://localhost:3000/health
```

### 3. æ–‡æ¡£è®¿é—®

å¼€å‘ç¯å¢ƒå¯åŠ¨åï¼Œè®¿é—® `http://localhost:3000/api-docs` æŸ¥çœ‹ Swagger API æ–‡æ¡£ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2024-12-01  
**æœ€åæ›´æ–°**: 2024-12-01  
**ç»´æŠ¤å›¢é˜Ÿ**: åç«¯å¼€å‘å›¢é˜Ÿ 